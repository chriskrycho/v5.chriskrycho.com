---
title: >
    Improving `jj-gcp` with <abbr title="JavaScript Object Notation">JSON</abbr> Schema and schemars
subtitle: |
    I don’t use this tool that often, but it’s good for it to work correctly when I do!

summary: >
    The little tool I use to generate descriptive branch names for jj is now more configurable and reliable. And I learned some things!

qualifiers:
    audience: |
        People interested in how building tools around generative <abbr>AI</abbr> systems actually works. Also assumes and does not explain a baseline of basic Rust knowledge, but you can probably understand the gist without that.

date: 2025-01-18T14:48:00-0700

tags:
    - Rust
    - AI
    - tools
    - Year of Shipping
    - Jujutsu
    - version control

---

I just published my most recent updates to [jj-gpc][tool], a little tool I [built][prev] back in November to generate more useful branch names than the form generated by jj itself.

<aside>

If you want to use the tool, this should do the trick:

```
cargo install --git https://github.com/chriskrycho/jj-gpc --tag v0.7.1
```

</aside>

Between when I shipped the tool and now, [Ollama][oll] added support for using <abbr>JSON</abbr> Schema to control the output of the models you invoke, and [ollama-rs][ollama-rs], the Rust library I use that wraps Ollama, likewise added support for it by way of the lovely [schemars][schemars] crate.

The basic idea is: if you provide a grammar or set of constraints for the output of a model, you can get *much* better results when trying to get out structured data, because it’s possible to validate *at generation time* whether the next token is valid by checking it against the specified grammar. There are two basic approaches to this out there: using actual *grammars*, in roughly [Backus-Naur form][bnf], and using <abbr>JSON</abbr> Schema with constraints on the data structures—but the latter [can include regexes][js-regex-docs], which makes <abbr>JSON</abbr> Schema *roughly* comparable in power to a more formal grammar.

Now, which one is easier to write *by hand* is no debate: <abbr title="Backus-Naur form">BNF</abbr> wins hands down. Which one is easier to programmatically generate is something else entirely, though, because [the schemars crate][schemars] makes it trivial to generate <abbr title="JavaScript Object Notation">JSON</abbr> Schema from Rust data structures, even including fancy bits like regular expression patterns. When I say trivial, I mean it. The whole data structure I defined, after a bit of mucking around, was this:

```rust
#[derive(JsonSchema, Deserialize, Debug)]
struct Branch(
    #[schemars(regex(pattern = "^[a-z]{1,10}+(-[a-z]{1,10}){2,4}$"))]
    String
);
```

It is a “tuple struct” which enforces a regex pattern on the `String` it wraps. That’s the whole thing. The regex requires that it be lowercase characters, separated by hyphens, with at least 3 and not more than 5 such words.

With that in place, I *finally* stopped getting occasional output like `` ```something-like-this ``, and yes, the `` ``` `` was being included in that. This constraint also meant I could get rid of the bit of inline regex-wrangling I was doing to normalize the output from the <abbr title="large language model">LLM</abbr>.

The big takeaways for me from this exercise:

1. Being able to use a <abbr title="JavaScript Object Notation">JSON</abbr> Schema like this is super handy for constraining model output. This is old news to folks who have been hacking on <abbr title="large language model">LLM</abbr>-based tools for a while, and I have *known* about this for quite some time, but it’s always something else to put it into practice, and I thought it would probably be new to at least some of you reading, as well!

2. The schemars library is *fantastic*. I used the inline version of regexes, because that was most convenient, but there are a bunch of other ways to do it, including referring to regexes in scope to refer to by name. Generating a <abbr title="JavaScript Object Notation">JSON</abbr> Schema with it was basically trivial.

3. A bonus: Avoiding “conversational” prompts can be handy. It is easy to get in the habit of treating all <abbr title="large language model">LLM</abbr> interactions as a variant of the chat-based model most of the existing tools use, but in practice what I actually wanted here was a prompt that was *completely* non-conversational.

[tool]: https://github.com/chriskrycho/jj-gpc
[prev]: https://v5.chriskrycho.com/journal/new-tool-jj-gpc/
[json-schema]: https://json-schema.org
[oll]: https://ollama.com
[ollama-rs]: https://github.com/pepperoni21/ollama-rs
[schemars]: https://github.com/GREsau/schemars
[bnf]: https://en.wikipedia.org/wiki/Backus–Naur_form
[js-regex-docs]: https://json-schema.org/understanding-json-schema/reference/regular_expressions